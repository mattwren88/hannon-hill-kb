[
  {
    "id": "developing-in-cascade-script-formats-date-tool-essentials",
    "title": "Date Tool Essentials",
    "category": "Developing In Cascade",
    "body": "Overview The Date Tool lets you retrieve, parse, format, and compare date/time values in Velocity. It is especially useful when you are working with Unix timestamps in milliseconds (such as Index Block XML values), normalizing mixed time zones from feeds, or formatting human-readable dates for display.\n\nConvert Unix timestamps in milliseconds to Java Dates.\nParse formatted strings into Dates with toDate().\nFormat Dates for display with format().\nCompare two dates using difference(). .getDate() vs .toDate() Use .getDate() when you already have a Unix timestamp in milliseconds (for example, from metadata like $currentPage.metadata.startDate) and need a Java Date for formatting or\n comparison. If you omit the argument,\n getDate() returns the current moment.\nIf your input is a human-readable date string (like 03-21-2024), use .toDate() instead. The pattern you pass must match the string exactly; if it does not, you will get null rather than a parsed date.\nA quick rule: numeric Unix timestamps go to getDate(), formatted strings go to toDate(). Keep your patterns consistent so your parsing and display stay in sync.\nThese two are easy to mix up: getDate() expects (or defaults to) a numeric timestamp and hands you back a Date object, while toDate() converts a string to a Date object by matching the syntax in the string with your pattern.\nQuick compare: getDate vs toDate.\n\n\nMethod\nInput\nWhen to use\n\n\n\n\n$_DateTool.getDate()\nUnix timestamp in milliseconds\nConvert a numeric timestamp to a Date for formatting or comparison.\n\n\n$_DateTool.toDate()\nFormatted date string + pattern\nParse a human-readable date string into a Date.\n\n\n\nPitfall - getDate() expects milliseconds. If you pass seconds, your date will land near 1970.\n.getDate examples\nMany $currentPage properties already return Date objects, so you can format them directly without conversion:\n## These already return Date objects - no conversion needed\n$currentPage.lastPublishedOn ## Date of last publish\n$currentPage.createdOn ## Date asset was created\n$currentPage.lastModified ## Date of last modification\n\n## Get the current date/time\n$_DateTool.getDate()\nFormat these dates directly:\n## Format the last published date for a byline\nPublished $_DateTool.format(\"MMM d, yyyy\", $currentPage.lastPublishedOn)\n## Output: Published Jan 15, 2026\n\n## Format creation date\nCreated $_DateTool.format(\"MMMM d, yyyy\", $currentPage.createdOn)\n## Output: Created January 10, 2026\nData Definition date/time fields store timestamps as strings, so you need to convert them with getDate() before formatting:\n## Format a date/time field from a Data Definition\n#set ($dateNode = $currentPage.getStructuredDataNode(\"date-time\").textValue)#set ($eventDate = $_DateTool.getDate($dateNode))$_DateTool.format(\"MMMM d, yyyy\", $eventDate)\n## Output: March 15, 2026\n.toDate examples\nUse toDate() when you have a date as a string and need to parse it into a Date object:\n## Parse a date string - pattern must match the input format exactly\n#set ($dateString = \"03-21-2024\")\n#set ($date = $_DateTool.toDate(\"MM-dd-yyyy\", $dateString))\n$_DateTool.format(\"MMMM d, yyyy\", $date)\n## Output: March 21, 2024\n## ISO-style date format (common in feeds and APIs)\n#set ($shipDateString = \"2024-07-05\")\n#set ($shipDate = $_DateTool.toDate(\"yyyy-MM-dd\", $shipDateString))\n$_DateTool.format(\"MMM d, yyyy\", $shipDate)\n## Output: Jul 5, 2024\n## Date with time - useful for event timestamps\n#set ($stamp = \"2024-07-05 14:30:00\")\n#set ($stampDate = $_DateTool.toDate(\"yyyy-MM-dd HH:mm:ss\", $stamp))\n$_DateTool.format(\"EEEE, MMM d 'at' h:mma\", $stampDate)\n## Output: Friday, Jul 5 at 2:30PM\nReal-world scenarios\nEvent listing with metadata dates:\n## Display event start date from page metadata\n#set ($startMillis = $currentPage.metadata.startDate)\n#if ($startMillis && $startMillis > 0)\n #set ($eventDate = $_DateTool.getDate($startMillis))\n <time datetime=\"$_DateTool.format('yyyy-MM-dd', $eventDate)\">\n $_DateTool.format(\"MMMM d, yyyy\", $eventDate)\n </time>\n#end\nNews article with published date:\n## Format last published date for byline\n#set ($pubDate = $_DateTool.getDate($currentPage.lastPublishedOn))\nPublished $_DateTool.format(\"MMM d, yyyy\", $pubDate)\nWorking with Index Blocks\nProcessing dates from Index Block XML:\n## Index Block provides timestamps in milliseconds\n#foreach ($page in $_XPathTool.selectNodes($contentRoot, \"//system-page\"))\n #set ($lastMod = $_XPathTool.selectSingleNode($page, \"last-modified-on\"))\n #set ($lastModDate = $_DateTool.getDate($lastMod.value))\n\n <li>\n $_XPathTool.selectSingleNode($page, \"title\").value\n - Updated $_DateTool.format(\"M/d/yy\", $lastModDate)\n </li>\n#end\nFiltering Index Block results by date:\n## Show only items modified in the last 30 days\n#set ($now = $_DateTool.getDate())\n#foreach ($page in $_XPathTool.selectNodes($contentRoot, \"//system-page\"))\n #set ($lastModMillis = $_XPathTool.selectSingleNode($page, \"last-modified-on\").value)\n #set ($lastModDate = $_DateTool.getDate($lastModMillis))\n #set ($diff = $_DateTool.difference($lastModDate, $now))\n\n #if ($diff.days <= 30)\n ## Display this item\n #end\n#end\nHandling edge cases\nNull-safe date handling:\n## Always check for null before formatting\n#set ($startMillis = $currentPage.metadata.startDate)\n#if ($startMillis && $startMillis > 0)\n #set ($startDate = $_DateTool.getDate($startMillis))\n $_DateTool.format(\"MMMM d, yyyy\", $startDate)\n#else\n Date not set\n#end\nPattern mismatch returns null:\n## toDate returns null if pattern doesn't match input\n#set ($input = \"March 15, 2024\")\n#set ($wrongPattern = $_DateTool.toDate(\"MM-dd-yyyy\", $input)) ## null\n#set ($rightPattern = $_DateTool.toDate(\"MMMM d, yyyy\", $input)) ## works\n\n#if (!$rightPattern)\n Could not parse date\n#end\nEmpty string handling:\n## Empty strings also return null\n#set ($emptyDate = \"\")\n#set ($parsed = $_DateTool.toDate(\"yyyy-MM-dd\", $emptyDate))\n\n#if (!$parsed)\n No date provided\n#end Using difference() difference() returns a Comparison object that describes the distance between two dates. When printed, it renders a human-readable value (like 5 months), and it also includes structured fields like days, months, relative, and full.\nParsing dates for comparison\nMost real-world use starts by converting a string into a Date. Keep the format string aligned with your input (this is the part that usually breaks).\n#set ($today = $_DateTool.getDate())\n\n## Example input: \"07-04-26\" (MM-dd-yy)\n#set ($manualDate = \"07-04-26\")\n#set ($targetDate = $_DateTool.toDate(\"MM-dd-yy\", $manualDate))\n\n$today ## Wed Jan 14 14:36:28 EST 2026\n$targetDate ## Sat Jul 04 00:00:00 EDT 2026\nBasic example: distance between two dates\nUse difference(dateA, dateB) when you want the distance between two dates. This is best for countdowns, &#8220;time since&#8221; labels, or comparisons used in logic.\n#set ($today = $_DateTool.getDate())\n#set ($manualDate = \"07-04-26\")\n#set ($targetDate = $_DateTool.toDate(\"MM-dd-yy\", $manualDate))\n\n## Compare today to the target date\n#set ($difference = $_DateTool.difference($today, $targetDate))\n\n$today ## Wed Jan 14 14:36:28 EST 2026\n$targetDate ## Sat Jul 04 00:00:00 EDT 2026\n$difference ## 5 months\nUseful fields on the Comparison object\nThe returned object is more than just a string. These are the fields you&#8217;ll actually use in templates and UI labels:\n$difference.abbr ## 5 mos\n$difference.difference ## 5 months\n$difference.relative ## 5 months later\n$difference.full ## 5 months 2 weeks 6 days 8 hours 23 minutes ...\n\n$difference.days ## 170\n$difference.weeks ## 24\n$difference.months ## 5\n$difference.years ## 0\n\n$difference.class ## class org.apache.velocity.tools.generic.ComparisonDateTool$Comparison\nBranching UI label: &#8220;Still coming up&#8221; vs &#8220;Happened&#8221;\nFor simple branching logic, days is the easiest field to work with. Just be consistent about argument order. In the example below, a positive number means the target date is in the future (relative to today).\n#set ($today = $_DateTool.getDate())\n#set ($manualDate = \"07-04-26\")\n#set ($targetDate = $_DateTool.toDate(\"MM-dd-yy\", $manualDate))\n#set ($difference = $_DateTool.difference($today, $targetDate))\n\n#if ($difference.days >= 0)\n Still coming up (in $difference.abbr)\n#else\n Happened ($difference.abbr ago)\n#end\nTip: For &#8220;ago&#8221; labels, you can also use $difference.abs() if you want a cleaner positive duration (example: 5 months instead of -5 months). whenIs() basics whenIs() answers the more human question: &#8220;When is A relative to B?&#8221; It also returns a Comparison object, but the output is naturally directional (earlier / later), which is great for client-facing labels.\nNo-arg usage: &#8220;now&#8221;\n## today is January 13, 2026 in this example\n#set ($today = $_DateTool.getDate())\n\n#set ($whenIs = $_DateTool.whenIs($today))\n$whenIs\n## now\nComparing two dates (both directions)\nArgument order matters. Swapping them flips earlier vs later.\n#set ($today = $_DateTool.getDate())\n\n#set ($manualDate = \"July 4, 2026\")\n#set ($targetDate = $_DateTool.toDate(\"MMMM dd, yyyy\", $manualDate))\n\n$targetDate\n## Sat Jul 04 00:00:00 EDT 2026\n\n## Target compared to today\n#set ($whenIsA = $_DateTool.whenIs($targetDate, $today))\n$whenIsA\n## 5 months earlier\n\n## Today compared to target\n#set ($whenIsB = $_DateTool.whenIs($today, $targetDate))\n$whenIsB\n## 5 months later\nUseful fields (same Comparison object)\nSame object structure as difference(), but the human strings are usually what you want to show clients (relative, abbr, full).\n$whenIsB.abbr ## 5 mos later\n$whenIsB.relative ## 5 months later\n$whenIsB.difference ## 5 months\n$whenIsB.full ## 5 months 3 weeks 7 hours ... later\n\n$whenIsB.days ## 171\n$whenIsB.months ## 5\n$whenIsB.years ## 0\n\n$whenIsB.class ## class org.apache.velocity.tools.generic.ComparisonDateTool$Comparison\nBranching UI label: &#8220;didn&#8217;t happen yet&#8221; vs &#8220;you missed it&#8221;\nThis is a clean pattern for client-friendly messaging. Just decide what &#8220;positive&#8221; means for your argument order and stick to it.\n#set ($today = $_DateTool.getDate())\n#set ($manualDate = \"July 4, 2026\")\n#set ($targetDate = $_DateTool.toDate(\"MMMM dd, yyyy\", $manualDate))\n\n## \"today relative to target\"\n#set ($whenIs = $_DateTool.whenIs($today, $targetDate))\n\n#if ($whenIs.days > 0)\n Didn't happen yet ($whenIs.abbr)\n#else\n You missed it ($whenIs.abbr)\n#end getCalendar basics getCalendar() returns a Java Calendar object representing the current date and time in Cascade&#8217;s configured time zone. Use it when you need to read specific parts of &#8220;now&#8221; (year, month, day, weekday, hour) as numeric values for logic.\n#set ($cal = $_DateTool.getCalendar())\n\n## Calendar field IDs (numbers) are used by:\n## $cal.get(fieldId)\n\n$cal.get(1) ## YEAR\n## Example output: 2026\n\n$cal.get(2) ## MONTH (zero-based: January = 0)\n## Example output: 0\n\n$cal.get(5) ## DAY_OF_MONTH\n## Example output: 15\n\n$cal.get(7) ## DAY_OF_WEEK (Sunday = 1 ... Saturday = 7)\n## Example output: 5\n\n$cal.get(11) ## HOUR_OF_DAY (0&#8211;23)\n## Example output: 15\nThese numeric field IDs are standard Java Calendar constants. You&#8217;ll typically only need a small subset of them when working with getCalendar().\n\n\n\nField ID\nMeaning\nNotes\n\n\n\n\n1\nYEAR\n4-digit year\n\n\n2\nMONTH\nZero-based: January = 0\n\n\n5\nDAY_OF_MONTH\n1&#8211;31\n\n\n6\nDAY_OF_YEAR\n1&#8211;365/366\n\n\n7\nDAY_OF_WEEK\nSunday = 1, Saturday = 7\n\n\n9\nAM_PM\n0 = AM, 1 = PM\n\n\n11\nHOUR_OF_DAY\n24-hour clock (0&#8211;23)\n\n\n12\nMINUTE\n0&#8211;59\n\n\n\nImportant: getCalendar() is best treated as a read-only helper in Cascade. For date math or comparisons, use difference() or whenIs(). For formatting, use format(). Formatting output Keep your output consistent by reusing a small set of format strings. Popular options include:\n\nMMMM d, yyyy\nMMM d, yyyy\nyyyy-MM-dd\nyyyyMMdd\nEEEE, MMMM d, yyyy 'at'\n h:mma\n \nyyyy-MM-dd'T'HH:mm:ssXXX (ISO 8601 with offset)\nHH:mm (24-hour) and h:mma (12-hour)\n'Week' w, yyyy (week number)\n\nCommon symbols:\nCommon date format symbols\n\n\nSymbol\nMeaning\nVariations / examples\n\n\n\n\ny\nYear\ny=2024 yy=24 yyyy=2024\n\n\nM\nMonth (1-12)\nM=8 MM=08 MMM=Aug MMMM=August\n\n\nd\nDay of month\nd=5 dd=05\n\n\nE\nDay name\nE=Wed EEE=Wed EEEE=Wednesday\n\n\nH\nHour 0-23\nH=9 HH=09\n\n\nh\nHour 1-12\nh=9 hh=09\n\n\nm\nMinute\nm=3 mm=03\n\n\ns\nSecond\ns=7 ss=07\n\n\na\nAM/PM marker\na=AM\n\n\nz\nTime zone abbreviation\nz=EDT zzzz=Eastern Daylight Time\n\n\nX\nISO 8601 offset\nX=-5 XX=-0500 XXX=-05:00\n\n\nw\nWeek of year\nw=34 ww=34\n\n\n\nPractical examples using the same timestamp:\n#set ($stamp = \"2024-08-21 13:45:00\")\n#set ($date = $_DateTool.toDate(\"yyyy-MM-dd HH:mm:ss\", $stamp))\n\n$_DateTool.format(\"MMMM d, yyyy\", $date)\n## August 21, 2024\n\n$_DateTool.format(\"EEE, MMM d 'at' h:mma\", $date)\n## Wed, Aug 21 at 1:45PM\n\n$_DateTool.format(\"z\", $date)\n## EDT$_DateTool.format(\"zzzz\", $date)## Eastern Daylight Time Handling time zones Feeds frequently include timestamps paired with separate time zone identifiers (for example, 2024-08-21 13:00:00 with America/Chicago). If you format those dates using your server's default time zone, event times can appear hours off. To display the correct local time, you need to explicitly apply each event's time zone when formatting.\nIn most cases (all Cascade Cloud environments and most on-prem environments), you can pass a time zone string directly to $_DateTool.getTimeZone().getTimeZone():\n#set ($startDate = $currentPage.createdOn)\n\n## Default server time zone\n$_DateTool.format('EE MMM dd HH:mm:ss z yyyy', $startDate)\n## Output: Wed Aug 21 14:08:26 EDT 2019\n\n## Converted to UTC\n$_DateTool.format('EE MMM dd HH:mm:ss z yyyy', $startDate, $_DateTool.getLocale(), $_DateTool.getTimeZone().getTimeZone(\"UTC\"))\n## Output: Wed Aug 21 18:08:26 UTC 2019\n\n## Converted to Pacific time\n$_DateTool.format('EE MMM dd HH:mm:ss z yyyy', $startDate, $_DateTool.getLocale(), $_DateTool.getTimeZone().getTimeZone(\"America/Los_Angeles\"))\n## Output: Wed Aug 21 11:08:26 PDT 2019\nIn some on-premise instances, this call may throw an exception like the following due to a missing JVM startup parameter:VelocityException: ASTMethod.execute() : exception invoking method 'getTimeZone' in class sun.util.calendar.ZoneInfo\nYou can verify whether your instance has this restriction by testing these two calls:\n## This works on all instances - returns a ZoneInfo object\n$_DateTool.getTimeZone()\n\n## This fails on some on-prem instances\n$_DateTool.getTimeZone().getTimeZone(\"UTC\")\nIf $_DateTool.getTimeZone().getTimeZone(\"UTC\") fails with an error, see Troubleshooting: Zone Info for the fix. You can also consider the workaround listed in the following section (\"reflection\").\nOn-premises workaround (reflection)\nThis approach uses Java reflection to access the TimeZone class directly. It can work in the event that you don't have the ability to add the JVM parameter as specified above.\n## Get the TimeZone class via reflection\n#set ($tzClass = $_DateTool.getTimeZone().getClass().forName(\"java.util.TimeZone\"))\n\n## Create a TimeZone object for UTC\n#set ($utcTz = $tzClass.getMethod(\"getTimeZone\", $tzClass.forName(\"java.lang.String\")).invoke(null, \"UTC\"))\n\n## Format a date in UTC\n$_DateTool.format('EE MMM dd HH:mm:ss z yyyy', $currentPage.createdOn, $_DateTool.getLocale(), $utcTz)\n## Output: Wed Aug 21 18:08:26 UTC 2019\nProcessing feeds with mixed time zones\nWhen processing a JSON feed where each event has its own time zone, use the reflection approach with a dynamic zone value:\n## Assume feed fields: $event.start (yyyy-MM-dd HH:mm:ss), $event.timezone (e.g., America/Chicago)\n\n## Set up the TimeZone class reference once\n#set ($tzClass = $_DateTool.getTimeZone().getClass().forName(\"java.util.TimeZone\"))\n\n#foreach ($event in $events)\n ## Get the TimeZone for this event\n #set ($eventTz = $tzClass.getMethod(\"getTimeZone\", $tzClass.forName(\"java.lang.String\")).invoke(null, $event.timezone))\n\n ## Parse the date string\n #set ($parser = $_DateTool.getDateFormat(\"yyyy-MM-dd HH:mm:ss\", $_DateTool.getLocale(), $eventTz))\n #set ($startDate = $parser.parse($event.start))\n\n ## Format with the event's time zone\n $_DateTool.format(\"MMM d, yyyy 'at' h:mma z\", $startDate, $_DateTool.getLocale(), $eventTz)\n ## Example output: Aug 21, 2024 at 1:00PM CDT\n#end\nValidating time zone IDs\nTime zone strings like America/Chicago or America/New_York must match Java's recognized identifiers. To see all valid IDs:\n#set ($tzClass = $_DateTool.getTimeZone().getClass().forName(\"java.util.TimeZone\"))\n#set ($allIds = $tzClass.getMethod(\"getAvailableIDs\", null).invoke(null, null))\n$_ListTool.toList($allIds)\nThis returns a list of all accepted time zone identifiers. As long as your feed's time zone values appear in this list, they will work with the examples above. Sorting by date Once you have dates, you'll often need to sort content chronologically. Cascade offers a few approaches depending on your data source.\nIndex Block sorting\nThe simplest approach is to configure sorting directly in the Index Block asset. Under the block's settings, you can sort by system properties like Last Modified Date, Created Date, or Start Date (for pages with date metadata). This handles sorting before your Velocity code runs.\nSorting with $_.query()\nThe $_.query() tool lets you query assets directly in Velocity and sort the results by date fields. Use sortBy() to specify the field and sortDirection() for ascending or descending order.\n## Query articles sorted by last modified date (newest first)\n#set ($results = $_.query().byContentType(\"Article\").sortBy(\"modified\").sortDirection(\"desc\").execute())\n\n#foreach ($page in $results)\n $page.name - $_DateTool.format(\"MMM d, yyyy\", $page.lastModified)\n#end\nAvailable date fields for sortBy(): created, modified, startDate, endDate, and reviewDate.\n## Sort events by start date (ascending)\n#set ($events = $_.query().byContentType(\"Event\").sortBy(\"startDate\").sortDirection(\"asc\").execute())\nSorting with $_SortTool\nWhen you need to sort a collection in Velocity, use $_SortTool. This is useful when working with structured data or when you need custom sort logic.\n## Sort a list of pages by lastModified (ascending)\n#set ($sorted = $_SortTool.sort($pages, \"lastModified\"))\n\n## Sort descending (newest first)\n#set ($sorted = $_SortTool.sort($pages, \"lastModified:desc\"))\n\n## Sort by a metadata date field\n#set ($sorted = $_SortTool.sort($pages, \"metadata.startDate:desc\"))\nSorting with XPath\nWhen processing Index Block XML, you can sort nodes directly in your XPath expression using sort-by. Date fields from Index Blocks are Unix timestamps in milliseconds, which sort numerically.\n## Sort pages by last-modified-on, newest first\n#set ($pages = $_XPathTool.selectNodes(\n $contentRoot,\n \"//system-page[sort-by(last-modified-on, 'number', 'descending')]\"\n))\n\n#foreach ($page in $pages)\n #set ($lastMod = $_XPathTool.selectSingleNode($page, \"last-modified-on\").value)\n #set ($date = $_DateTool.getDate($lastMod))\n $_DateTool.format(\"MMM d, yyyy\", $date)\n#end\nFor metadata date fields stored as timestamps, use the same numeric sort:\n## Sort by a dynamic metadata date field (e.g., event start date)\n#set ($events = $_XPathTool.selectNodes(\n $contentRoot,\n \"//system-page[sort-by(dynamic-metadata[name='start-date']/value, 'number', 'ascending')]\"\n))",
    "url": "./date-tool-essentials.html"
  },
  {
    "id": "developing-in-cascade-script-formats-query-tool-directives",
    "title": "Query Tool Directives",
    "category": "Developing In Cascade",
    "body": "Overview Introduced in Cascade CMS 8.26, Query Directives are an alternative to the .execute() method on the Query API. They process results one asset at a time instead of loading everything into a list, which means they can handle up to 100,000 results (compared to the 2,000 limit with .execute()).\nThere are three directives:\n\n#queryexecute &#8211; iterate over results and output content for each asset\n#queryfilter &#8211; apply custom filtering logic before maxResults() is applied\n#querysortvalue &#8211; define a custom sort value before maxResults() is applied\n\nAll three use the same basic pattern: pass a query object and an asset variable, write your logic in the body, and close with #end.\nTip: Use $enabledCustomDirectives to check which custom directives are available in your CMS environment. When to use directives Quick decision guide: .execute() vs directives\n\n\nScenario\nUse\n\n\n\n\nResults under 2,000 with no custom filtering or sorting\n.execute()\n\n\nNeed more than 2,000 results\n#queryexecute\n\n\nNeed to filter on values not available via built-in query methods\n#queryfilter\n\n\nNeed to sort by structured data, dynamic metadata, or computed values\n#querysortvalue\n\n\nUnder 2,000 results but need custom filtering or sorting\n#queryfilter / #querysortvalue + .execute()\n\n\nLarge dataset with custom filter + sort + output\nAll three combined #queryexecute Replaces the .execute() + #foreach pattern. The directive iterates over results directly, processing one asset at a time. Supports maxResults() up to 100,000.\nAvailable arguments for #queryexecute.\n\n\nArgument\nType\nDescription\n\n\n\n\nquery\nSearchQueryrequired\nA query object.\n\n\nasset\nObjectrequired\nPopulated automatically by the system. Points to a new asset on each iteration, while the old asset gets cleared to save memory.\n\n\nbody\nLogicrequired\nLogic to execute and output for each asset.\n\n\n\nImportant: Unlike #foreach, this directive clears the previous asset from memory on each iteration. This means $foreach.count, $foreach.hasNext, $foreach.index, and other loop variables are not available. If you need a counter or first-iteration check, manage it yourself with a #set variable.\nBasic usage\nBuild a query, then pass it to #queryexecute instead of calling .execute().\n## Build the query (do NOT call .execute())\n#set ($query = $_.query().byContentType(\"Article\").maxResults(10).sortBy(\"startDate\").sortDirection(\"desc\"))\n\n## Iterate with the directive\n#queryexecute($query, $page)\n <h3>$page.metadata.title</h3>\n <p>$page.metadata.summary</p>\n#end\nSitemap generation\nQuery directives are well suited for sitemaps where the result set can be very large.\n#set ($query = $_.query().byContentType(\"Default-Page\").indexableOnly(true).preloadDynamicMetadata())\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n #queryexecute($query, $page)\n <url>\n <loc>https://yoursite.com${page.path}.html</loc>\n </url>\n #end\n</urlset>\nLarge datasets with preloaded data\nWhen working with structured data across many results, preload it on the query to avoid per-asset database round trips.\n#set ($query = $_.query().byContentType(\"Event\").preloadStructuredData().maxResults(5000).sortBy(\"startDate\").sortDirection(\"asc\"))\n\n#queryexecute($query, $event)\n #set ($start = $event.getStructuredDataNode(\"startDateTime\").textValue)\n #set ($title = $event.metadata.title)\n <div class=\"event-card\">\n <h3>$title</h3>\n <span>$start</span>\n </div>\n#end\nCross-site query\nQuery across all sites for assets using a shared Content Type.\n#set ($query = $_.query().byContentType(\"site://Global/Shared Page\").searchAcrossAllSites().preloadDynamicMetadata().maxResults(10000))\n\n#queryexecute($query, $page)\n <li>\n <a href=\"${page.link}\">${page.metadata.title}</a>\n <small>(${page.siteName})</small>\n </li>\n#end\nJSON feed\nSince loop variables aren't available, use a flag variable like $isFirstIteration for comma separation in JSON output.\n#set($query = $_.query().byContentType(\"Event\").preloadStructuredData().sortBy(\"startDate\"))\n#set($isFirstIteration = true)\n\n[\n#queryexecute($query, $event)\n #if(!$isFirstIteration),#end\n #set($title = $_EscapeTool.java($event.metadata.title.trim()))\n #set($date = $event.getStructuredDataNode(\"event-date\").textValue)\n {\n \"title\": \"${title}\",\n \"date\": \"${date}\",\n \"url\": \"[system-asset]${event.link}[/system-asset]\"\n }\n #set($isFirstIteration = false)\n#end\n]\nThe key pattern: #if(!$isFirstIteration),#end outputs a comma before every entry except the first, replacing what you'd normally do with $foreach.hasNext. #queryfilter Executes body logic on each asset matching a query before maxResults() is applied. If the body logic returns true, the asset is included in the results.\nAvailable arguments for #queryfilter.\n\n\nArgument\nType\nDescription\n\n\n\n\nquery\nSearchQueryrequired\nA query object.\n\n\nasset\nObjectrequired\nPopulated automatically by the system. Points to a new asset on each iteration, while the old asset gets cleared to save memory.\n\n\nbody\nLogicrequired\nLogic to execute. Must return the exact string true to include the asset.\n\n\n\nNote: Built-in filtering methods result in faster performance and this directive should only be used for scenarios where there is no built-in method. For example, .bySiteName will be faster than using #queryfilter with Site name comparison logic.\nTip: You can move your logic into #queryexecute temporarily to test the functionality and ensure that your body logic returns the exact string true.\nTip: The preferred way to return a value from the filter body is to use #set to capture the result, then output it:\n#queryfilter($query, $asset)\n #set($result = $asset.path.contains(\"index\"))\n $result\n#end\nThis pattern handles negation and multiple conditions cleanly without needing #if/true/#end.\nFilter by path pattern\nOnly include index pages from the query results.\n#set ($query = $_.query().byContentType(\"Article\"))\n\n#queryfilter($query, $asset)\n $asset.path.contains(\"index\")\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end\nFilter by structured data value\nInclude only assets where a structured data checkbox has a specific value. This is useful for multi-value fields where built-in methods can't filter directly.\n#set ($query = $_.query().byContentType(\"News\").preloadStructuredData())\n\n#queryfilter($query, $asset)\n $asset.getStructuredDataNode(\"details/is-featured\").textValue.contains(\"Yes\")\n#end\n\n#queryexecute($query, $page)\n <div class=\"featured-news\">\n <h3>${page.metadata.title}</h3>\n <p>${page.metadata.summary}</p>\n </div>\n#end\nFilter by dynamic metadata\nInclude only assets where a dynamic metadata field matches a condition.\n#set ($query = $_.query().byContentType(\"Page\").preloadDynamicMetadata())\n\n#queryfilter($query, $asset)\n $asset.metadata.getDynamicField(\"display-in-nav\").value.contains(\"Yes\")\n#end\n\n#queryexecute($query, $page)\n <li><a href=\"${page.link}\">${page.metadata.displayName}</a></li>\n#end\nFilter by empty or populated field\nUse $_PropertyTool.isNotEmpty() to include only assets where a field has a value. Negate it to find assets where a field is empty.\n## Only pages where the author field is populated\n#set ($query = $_.query().byContentType(\"Article\"))\n\n#queryfilter($query, $asset)\n $_PropertyTool.isNotEmpty($asset.metadata.author)\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title} &mdash; ${page.metadata.author}</li>\n#end\nTo find assets where a field is empty, negate the check with #set:\n#queryfilter($query, $asset)\n #set($result = !$_PropertyTool.isNotEmpty($asset.metadata.author))\n $result\n#end\nMultiple conditions\nUse #set to combine conditions with && or ||. The result is captured as a boolean and output directly.\n#set ($query = $_.query().byContentType(\"Article\").preloadStructuredData())\n\n#queryfilter($query, $asset)\n #set($result = $asset.path.contains(\"index\") && $asset.getStructuredDataNode(\"details/is-featured\").textValue.contains(\"Yes\"))\n $result\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end\nOR logic works the same way:\n#queryfilter($query, $asset)\n #set($result = $asset.metadata.title.contains(\"News\") || $asset.metadata.title.contains(\"Events\"))\n $result\n#end\nExclude pattern\nTo exclude assets matching a condition, negate the check.\n#set ($query = $_.query().byContentType(\"Article\"))\n\n#queryfilter($query, $asset)\n #set($result = !$asset.path.contains(\"/archive/\"))\n $result\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end #querysortvalue Executes body logic on each asset to determine the sort value before maxResults() is applied. This is an alternative to .sortBy() and can be used with both #queryexecute and .execute().\nAvailable arguments for #querysortvalue.\n\n\nArgument\nType\nDescription\n\n\n\n\nquery\nSearchQueryrequired\nA query object.\n\n\nasset\nObjectrequired\nPopulated automatically by the system. Points to a new asset on each iteration, while the old asset gets cleared to save memory.\n\n\nbody\nLogicrequired\nLogic to execute. The return value is used as the sort key.\n\n\n\nNote: Built-in sorting methods result in faster performance. For example, .sortBy(\"name\") will be faster than using #querysortvalue with $asset.name as the logic.\nTips:\n\nThis directive sorts by string only. When sorting numbers, use $_NumberTool.withPadding to ensure results sort correctly.\nThis directive respects the value passed into .sortDirection() on the query.\n\n\nSort by metadata title\n#set ($query = $_.query().byContentType(\"Article\"))\n\n#querysortvalue($query, $asset)\n $asset.metadata.title\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end\nSort by structured data text field\nSort by a text value stored in structured data rather than a metadata field.\n#set ($query = $_.query().byContentType(\"Article\").preloadStructuredData().sortDirection(\"asc\"))\n\n#querysortvalue($query, $asset)\n $asset.getStructuredDataNode(\"title\").textValue\n#end\n\n#queryexecute($query, $page)\n <li>${page.getStructuredDataNode(\"title\").textValue}</li>\n#end\nNumeric sorting with $_NumberTool.withPadding\nSince #querysortvalue sorts by string, numeric values need padding to sort correctly (e.g., \"5\" would sort after \"10\" without padding).\n#set ($query = $_.query().byContentType(\"Course\").preloadStructuredData().sortDirection(\"asc\"))\n\n#querysortvalue($query, $asset)\n $_NumberTool.withPadding($asset.getStructuredDataNode(\"course-number\").textValue)\n#end\n\n#queryexecute($query, $course)\n <li>${course.getStructuredDataNode(\"course-number\").textValue} - ${course.metadata.title}</li>\n#end\nMulti-level sorting\nSince sorting is string-based, you can concatenate multiple values to sort by more than one field. The first value acts as the primary sort, the second as the tiebreaker, and so on.\nAlphabetical by last name, then first name\n#set ($query = $_.query().byContentType(\"Staff\").preloadStructuredData().sortDirection(\"asc\"))\n\n#querysortvalue($query, $asset)\n $asset.getStructuredDataNode(\"last-name\").textValue $asset.getStructuredDataNode(\"first-name\").textValue\n#end\n\n#queryexecute($query, $person)\n <li>${person.getStructuredDataNode(\"last-name\").textValue}, ${person.getStructuredDataNode(\"first-name\").textValue}</li>\n#end\nBy department number, then course name\n#set ($query = $_.query().byContentType(\"Course\").preloadStructuredData().sortDirection(\"asc\"))\n\n#querysortvalue($query, $asset)\n $_NumberTool.withPadding($asset.getStructuredDataNode(\"department-number\").textValue) $asset.metadata.title\n#end\n\n#queryexecute($query, $course)\n <li>${course.getStructuredDataNode(\"department-number\").textValue} - ${course.metadata.title}</li>\n#end\nNote the $_NumberTool.withPadding on the department number. Without it, department \"5\" would sort after \"10\" since it's comparing strings.\nBy author, then title\n#set ($query = $_.query().byContentType(\"Article\").sortDirection(\"asc\").maxResults(50))\n\n#querysortvalue($query, $asset)\n $asset.metadata.author $asset.metadata.title\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.author} &mdash; ${page.metadata.title}</li>\n#end\nSort by date stored in structured data\nDate strings like 01-15-2024 02:30:00 PM won't sort chronologically as plain strings because the month comes first. Convert the value to epoch milliseconds with $_DateTool so the sort is truly chronological.\n#set ($query = $_.query().byContentType(\"Event\").preloadStructuredData().sortDirection(\"desc\").maxResults(20))\n\n#querysortvalue($query, $asset)\n #set ($dt = $asset.getStructuredDataNode(\"event-date\").textValue)\n #if($_PropertyTool.isNotEmpty($dt))\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n ${date.getTime()}\n #else\n 0\n #end\n#end\n\n#queryexecute($query, $event)\n <li>\n ${event.metadata.title}\n <span>${event.getStructuredDataNode(\"event-date\").textValue}</span>\n </li>\n#end\nThe format string passed to $_DateTool.toDate() must match the format stored in your data definition. Adjust it to match your field's format.\nSort descending\nThe directive respects .sortDirection(). Set it on the query object before using #querysortvalue.\n#set ($query = $_.query().byContentType(\"News\").sortDirection(\"desc\"))\n\n#querysortvalue($query, $asset)\n $asset.metadata.title\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end Combining directives All three directives can be used together on the same query. The order of operations is: #queryfilter runs first to narrow the results, then #querysortvalue determines the sort order, and finally #queryexecute outputs the results up to the maxResults() limit.\nFull example: filtered, sorted event listing\nQuery all events, filter to only featured ones, sort by a structured data date field, and output the first 50.\n## Build the query\n#set ($query = $_.query().byContentType(\"Event\").preloadStructuredData().sortDirection(\"asc\").maxResults(50))\n\n## Filter: only featured events\n#queryfilter($query, $asset)\n $asset.getStructuredDataNode(\"is-featured\").textValue.contains(\"Yes\")\n#end\n\n## Sort: by event date stored in structured data\n#querysortvalue($query, $asset)\n $asset.getStructuredDataNode(\"event-date\").textValue\n#end\n\n## Output\n<ul>\n#queryexecute($query, $event)\n <li>\n <strong>${event.metadata.title}</strong>\n <span>${event.getStructuredDataNode(\"event-date\").textValue}</span>\n </li>\n#end\n</ul>\nDate range filter with chronological sorting\nFilter to events within a specific date range and sort them chronologically. The filter parses each date into epoch milliseconds for comparison, and the sort does the same for ordering.\n#set ($query = $_.query().byContentType(\"Event\").preloadStructuredData().sortDirection(\"asc\").maxResults(100))\n#set ($rangeStart = $_DateTool.toDate(\"yyyy-MM-dd\", \"2024-01-01\").getTime())\n#set ($rangeEnd = $_DateTool.toDate(\"yyyy-MM-dd\", \"2024-12-31\").getTime())\n\n## Filter: only events in 2024\n#queryfilter($query, $asset)\n #set ($dt = $asset.getStructuredDataNode(\"event-date\").textValue)\n #if($_PropertyTool.isNotEmpty($dt))\n #set ($ts = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt).getTime())\n #if($ts >= $rangeStart && $ts <= $rangeEnd)\n true\n #end\n #end\n#end\n\n## Sort: chronological by event date\n#querysortvalue($query, $asset)\n #set ($dt = $asset.getStructuredDataNode(\"event-date\").textValue)\n #if($_PropertyTool.isNotEmpty($dt))\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n ${date.getTime()}\n #else\n 0\n #end\n#end\n\n## Output with formatted date\n#queryexecute($query, $event)\n #set ($dt = $event.getStructuredDataNode(\"event-date\").textValue)\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n #set ($formatted = $_DateTool.format(\"MMMM d, yyyy\", $date))\n <li>\n <strong>${event.metadata.title}</strong>\n <span>$formatted</span>\n </li>\n#end In-depth examples These examples demonstrate advanced patterns that build on the basics above. They reference a Content Type with the following fields. Adapt the content type path and field names to match your own setup.\n\nStructured data: title (text), event-date (datetime in MM-dd-yyyy hh:mm:ss a format), asset-chooser (page chooser)\nDynamic metadata: multiselect (multi-select), checkbox (checkbox), department (dropdown), radio (radio), noindex (radio)\nStandard metadata: title, author, displayName, summary, description, teaser, keywords, startDate, endDate\n\nFiltering\n Filter by all values in a multi-select field\n\nCheck that a multi-value field contains every expected value using multiple .contains() calls joined with &&.\n#set ($query = $_.query().byContentType(\"Article\").preloadDynamicMetadata().maxResults(-1))\n\n#queryfilter($query, $asset)\n #set ($cb = $asset.metadata.getDynamicField(\"checkbox\").value)\n #set($result = $cb.contains(\"Easy\") && $cb.contains(\"Fast\") && $cb.contains(\"Cheap\"))\n $result\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end\n\n Combine structured data, dynamic metadata, and standard metadata\n\nFilter using fields from three different sources in one condition. Preload both structured data and dynamic metadata on the query.\n#set ($query = $_.query().byContentType(\"Article\").preloadStructuredData().preloadDynamicMetadata().maxResults(-1))\n\n#queryfilter($query, $asset)\n #set($result = $_PropertyTool.isNotEmpty($asset.getStructuredDataNode(\"event-date\").textValue) && $asset.metadata.getDynamicField(\"checkbox\").value.contains(\"Easy\") && $asset.getStructuredDataNode(\"title\").textValue.contains(\"Guide\"))\n $result\n#end\n\n#queryexecute($query, $page)\n <li>${page.getStructuredDataNode(\"title\").textValue}</li>\n#end\n\n\nSorting\n Sort by field value, then by date chronologically\n\nConcatenate a text field with epoch milliseconds for a two-level sort. The text field acts as the primary sort, and the date as the tiebreaker.\n#set ($query = $_.query().byContentType(\"Event\").preloadStructuredData().preloadDynamicMetadata().sortDirection(\"asc\").maxResults(30))\n\n#querysortvalue($query, $asset)\n #set ($group = $asset.metadata.getDynamicField(\"department\").value)\n #set ($dt = $asset.getStructuredDataNode(\"event-date\").textValue)\n #if($_PropertyTool.isNotEmpty($dt))\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n ${group} ${date.getTime()}\n #else\n ${group} 0\n #end\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.getDynamicField(\"department\").value} &mdash; ${page.metadata.title}</li>\n#end\n\n\nCombined\n Most recent pages in a filtered category\n\nCombine #queryfilter to narrow by category, #querysortvalue to sort by date descending, and maxResults(10) to take only the top 10.\n#set ($query = $_.query().byContentType(\"Article\").preloadStructuredData().sortDirection(\"desc\").maxResults(10))\n\n#queryfilter($query, $asset)\n $asset.metadata.title.contains(\"Science\")\n#end\n\n#querysortvalue($query, $asset)\n #set ($dt = $asset.getStructuredDataNode(\"event-date\").textValue)\n #if($_PropertyTool.isNotEmpty($dt))\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n ${date.getTime()}\n #else\n 0\n #end\n#end\n\n#queryexecute($query, $page)\n <li>${page.metadata.title}</li>\n#end\n\n Three-field filter with two-field sort\n\nFilter on three conditions (dynamic metadata + standard metadata), then sort by two concatenated fields.\n#set ($query = $_.query().byContentType(\"Article\").preloadStructuredData().preloadDynamicMetadata().sortDirection(\"asc\").maxResults(25))\n\n#queryfilter($query, $asset)\n #set($result = $asset.metadata.getDynamicField(\"checkbox\").value.contains(\"Fast\") && $asset.metadata.getDynamicField(\"noindex\").value.contains(\"No\") && $_PropertyTool.isNotEmpty($asset.metadata.summary))\n $result\n#end\n\n#querysortvalue($query, $asset)\n $asset.metadata.getDynamicField(\"department\").value $asset.metadata.author\n#end\n\n#queryexecute($query, $page)\n <li>\n ${page.metadata.getDynamicField(\"department\").value} &mdash;\n ${page.metadata.author} &mdash;\n ${page.metadata.title}\n </li>\n#end\n\n Group results under dynamic headers\n\nSort by the grouping field so identical values are adjacent, then detect when the value changes to insert a header.\n#set ($query = $_.query().byContentType(\"Article\").preloadDynamicMetadata().sortDirection(\"asc\").maxResults(50))\n\n#querysortvalue($query, $asset)\n $asset.metadata.getDynamicField(\"department\").value $asset.metadata.title\n#end\n\n#set ($currentGroup = \"\")\n#queryexecute($query, $page)\n #set ($group = $page.metadata.getDynamicField(\"department\").value)\n #if($group != $currentGroup)\n <h3>$group</h3>\n #set ($currentGroup = $group)\n #end\n <li>${page.metadata.title}</li>\n#end\n\n\nAdvanced patterns\n Aggregate counts by field value\n\nUse a map to count how many pages have each value in a field. Arithmetic (+) only works inside #set directives, not inside method arguments like .put().\n#set ($query = $_.query().byContentType(\"Article\").preloadDynamicMetadata().maxResults(-1))\n#set ($counts = {\"Yes\": 0, \"No\": 0, \"Maybe\": 0})\n\n#queryexecute($query, $page)\n #set ($val = $page.metadata.getDynamicField(\"radio\").value)\n #if($val.contains(\"Yes\"))\n #set ($n = $counts.get(\"Yes\") + 1)\n #set ($dummy = $counts.put(\"Yes\", $n))\n #elseif($val.contains(\"No\"))\n #set ($n = $counts.get(\"No\") + 1)\n #set ($dummy = $counts.put(\"No\", $n))\n #elseif($val.contains(\"Maybe\"))\n #set ($n = $counts.get(\"Maybe\") + 1)\n #set ($dummy = $counts.put(\"Maybe\", $n))\n #end\n#end\nYes: $counts.get(\"Yes\"), No: $counts.get(\"No\"), Maybe: $counts.get(\"Maybe\")\n\n Parse, sort, and format dates for display\n\nFilter to pages with a date, sort chronologically using epoch milliseconds, then format the date for readable output with $_DateTool.format().\n#set ($query = $_.query().byContentType(\"Event\").preloadStructuredData().sortDirection(\"desc\").maxResults(15))\n\n#queryfilter($query, $asset)\n $_PropertyTool.isNotEmpty($asset.getStructuredDataNode(\"event-date\").textValue)\n#end\n\n#querysortvalue($query, $asset)\n #set ($dt = $asset.getStructuredDataNode(\"event-date\").textValue)\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n ${date.getTime()}\n#end\n\n#queryexecute($query, $event)\n #set ($dt = $event.getStructuredDataNode(\"event-date\").textValue)\n #set ($date = $_DateTool.toDate(\"MM-dd-yyyy hh:mm:ss a\", $dt))\n #set ($formatted = $_DateTool.format(\"MMMM d, yyyy\", $date))\n <li>\n <strong>${event.metadata.title}</strong>\n <span>$formatted</span>\n </li>\n#end\n\n Count pages per category using a map\n\nDefine a map of categories with initial counts of zero. Iterate all pages, check each category, and increment the count. Output the breakdown with #foreach on the map entries.\n#set ($query = $_.query().byContentType(\"Article\").maxResults(-1))\n#set ($cats = {\"Technology\": 0, \"Science\": 0, \"Education\": 0, \"Healthcare\": 0, \"Business\": 0})\n\n#queryexecute($query, $page)\n #set ($t = $page.metadata.title)\n #foreach($cat in $cats.keySet())\n #if($t.contains($cat))\n #set ($n = $cats.get($cat) + 1)\n #set ($dummy = $cats.put($cat, $n))\n #end\n #end\n#end\n\n<ul>\n#foreach($entry in $cats.entrySet())\n <li>$entry.key: $entry.value</li>\n#end\n</ul> Migration guide Converting an existing .execute() pattern to use directives is straightforward.\nBefore: .execute() + #foreach\n#set ($results = $_.query().byContentType(\"Article\").maxResults(10).sortBy(\"startDate\").sortDirection(\"desc\").execute())\n\n#foreach ($page in $results)\n <h3>$page.metadata.title</h3>\n <p>$page.metadata.summary</p>\n#end\nAfter: #queryexecute\n#set ($query = $_.query().byContentType(\"Article\").maxResults(10).sortBy(\"startDate\").sortDirection(\"desc\"))\n\n#queryexecute($query, $page)\n <h3>$page.metadata.title</h3>\n <p>$page.metadata.summary</p>\n#end\nKey changes:\n\nRemove .execute() from the query chain.\nReplace #foreach ($page in $results) with #queryexecute($query, $page).\nThe body stays the same.\n\nBefore: .execute() with manual filtering\n#set ($list = $_.query().byContentType(\"News\").preloadStructuredData().execute())\n\n#foreach ($page in $list)\n #if ($page.getStructuredDataNode(\"details/is-featured\").textValue.contains(\"Yes\"))\n <div>$page.metadata.title</div>\n #end\n#end\nAfter: #queryfilter + #queryexecute\n#set ($query = $_.query().byContentType(\"News\").preloadStructuredData())\n\n#queryfilter($query, $asset)\n $asset.getStructuredDataNode(\"details/is-featured\").textValue.contains(\"Yes\")\n#end\n\n#queryexecute($query, $page)\n <div>$page.metadata.title</div>\n#end\nKey changes:\n\nRemove .execute() and the #foreach/#if block.\nMove the condition into #queryfilter. The body must return the exact string true.\nUse #queryexecute for the output, now with only matching results.\n\nTip: With #queryfilter, the filtering happens before maxResults() is applied. This means you get the correct number of matching results, rather than filtering down from a potentially truncated list.",
    "url": "./query-tool-directives.html"
  },
  {
    "id": "developing-in-cascade-script-formats-velocity-best-practices",
    "title": "Best practices for performance",
    "category": "Developing In Cascade",
    "body": "Working with choosers When working with choosers, it is important to save repeated .asset calls to a variable and then access that variable's methods directly. Failure to do so will result in multiple round trips to the database when only a single round trip is necessary.\nConsider the following Velocity code which accesses an image file that has been selected in a chooser: \n#set ($image = $currentPage.getStructuredDataNode(\"image\"))## one database round trip#set ($imageLink = $image.asset.link)## another database round trip#set ($imageFileSize = $image.asset.fileSize) ## another database round trip#set ($imageWidth = $image.asset.dimensions.width)## another database round trip#set ($imageHeight = $image.asset.dimensions.height) \nAs indicated by the comments, each line with .asset is having to fetch the image from the database (forcing a round trip from the app to the database and back). \nRather than doing this, the code can be simplified by saving the chosen asset to a variable and then accessing methods of that variable:\n## one database round trip#set ($selectedImage = $currentPage.getStructuredDataNode(\"image\").asset) #set ($imageLink =$selectedImage.link) #set ($imageFileSize = $selectedImage.fileSize)#set ($imageWidth = $selectedImage.dimensions.width)#set ($imageHeight = $selectedImage.dimensions.height) Importing Formats #import directives in Formats require a round trip from the app to the database and back again. This is necessary in order for the app to retrieve the contents of the Format being imported at runtime. Due to this fact, it is important to limit the number of #import directives as much as possible in order to keep transformation times performant. \nConsider the following sample code snippet below which imports 3 Formats. Each of the imported Formats contains a single macro.\n## one database round trip#import (\"_cms/formats/shared/macros/stripTags\")## another database round trip#import (\"_cms/formats/shared/macros/escapeAll\")## another database round trip#import (\"_cms/formats/shared/macros/makeAccessible\")\nWhile this type of setup is clean and makes things very straightforward to manage (a single Format contains a single macro with a corresponding name), it requires 3 round trips to the database during the transformation of any Page on which the main Format is attached.\nIn order to prevent repeated #import calls like this, macros should instead be combined into fewer Formats so that fewer #import directives are needed.\nContinuing the example from above, the macros from the 3 separate Formats indicated above can be combined into a single Format (we'll name it utility for the purposes of this sample). Then, rather than importing 3 separate Formats to get access to the 3 individual macros, a single line will do the trick:\n## one database round trip#import (\"_cms/formats/shared/macros/utility\")\nNow, rather than making multiple trips back and forth to the database (adding to overall render times), only one trip is required and the main Format automatically has access to all of the macros needed for the transformation. Using the Query API Accessing Structured Data and Dynamic Metadata\nWhen working with the Query API, if you're accessing Structured Data or Dynamic Metadata fields for the queried assets, you should utilize the corresponding $_.query().preloadStructuredData and/or $_.query().preloadDynamicMetadata methods for a performance boost. \nPreloading Structured Data\nConsider the following code which loads 500 \"events\":\n#set ($events = $_.query().byContentType(\"event\").execute())#foreach ($event in $events) ## database round trip (x 500) #set($start = $event.getStructuredDataNode(\"startDateTime\").textValue) #set($end = $event.getStructuredDataNode(\"endDateTime\").textValue) #set($details = $event.getStructuredDataNode(\"details\").textValue) #set($link = $event.getStructuredDataNode(\"additional\").getChild(\"link\").textValue)## additional logic here#end\nIn the foreach loop here, the application will be required to make a database round trip for each of the 500 results in order to gather each asset's Structured Data. \nBy adding the \"preload\" method to the query as seen below:\n#set ($events = $_.query().byContentType(\"event\").preloadStructuredData().execute())\nThe initial query execution will take longer (since the application is gathering the related Structured Data for all 500 results upfront), but accessing this data in the foreach loop for each asset will be exponentially faster as the data is already in memory. \nPreloading Dynamic Metadata\nSimilar to above, you can preload dynamic metadata as well. Consider the following code in a scenario where the query is returning 500 assets:\n#set ($events = $_.query().byContentType(\"event\").execute())#foreach ($event in $events) ## database round trip (x 500) #set($showInNavMenu = $event.metadata.getDynamicField(\"display-in-nav\").value) #set($alternateTitle = $event.metadata.getDynamicField(\"alternate title\").value)## additional logic here #end\nIn order to increase performance, we can change the query line as follows which will preload the necessary dynamic metadata fields:\n#set ($events = $_.query().byContentType(\"event\").preloadDynamicMetadata().execute())\nThis will force the app to load all of the metadata fields upfront which prevents the repeated database round trips within the foreach loop.\nLeveraging the #queryexecute directive\nThe #queryexecute directive is an alternative to the .execute() method of the Query API. The main benefits of using this directive are as follows:\n\nIt bypasses the 2,000 asset limitation of the .execute() method (allowing for querying up to 100,000 assets).\nOn each iteration, the previous asset in stored in memory is removed from memory to allow for the processing of the remaining assets without hampering performance.",
    "url": "./velocity-best-practices.html"
  }
]
